[{"title":"vue全栈开发部署你需要知道的一些事","date":"2017-05-10T11:51:58.000Z","path":"2017/05/10/vue全栈开发部署你需要知道的一些事/","text":"个人博客：https://ykloveyxk.github.io/ 最近作为 超廉价劳动力 在帮学校做一个 app 的后台。技术选型的时候实在不想用已经用烂的 jquery + php + mysql 这一套。于是就选择了 Vue + mongodb + nodejs 的模式，也顺带看看这些新技术在实战中的具体表现。开发了一段时间，最近也差不多快完成了，当然免不了踩了一些坑，发出来和大家交流一下，也顺带说说这种技术栈的项目该如何部署。 注：本文不是开发教学文档，只是讨论我在部署阶段遇到的问题。如果你恰好也遇到，那么希望能够帮到你。😁 前端打包 使用 vue + node 进行全栈开发时，前后端是完全分离的，开发完成后需要将 vue 写的前端打包成静态页面部署在服务器上运行，不要直接在服务器上 node run dev……在这个阶段，需要注意以下几点： 1. 打包出现以下或类似错误 ERROR in static/js/0.8d18fe144f17fc217b92.js from UglifyJsUnexpected token punc «(», expected punc «:» [static/js/0.8d18fe144f17fc217b92.js:45,8] 解决方法： 安装es2015的转化器 1npm install --save-dev babel-preset-es2015 新建文件 .babelrc，增加内容 123&#123; \"presets\": [\"es2015\"]&#125; 这个错误其实解决起来很简单，就是利用Babel来转化你写的ES2015。但是在我的上篇文章中，有人提 issue 问过我这个问题，在这里就顺带说下。 2. 打包完成部署服务器后，字体图标不显示解决方案：http://blog.csdn.net/xiaoermingn/article/details/53543001 如果你引用了 font-awesome 或类似的字体图标库，发现部署在服务器上所有的字体图标都不显示了，那么你需要读读我上面列出的这篇文章。这是因为 webpack 有自己的字体文件加载方式。 服务器部署 1. 前端部署首先建议在服务器上部署nginx，具体部署方法百度有很多，大家自行查找。部署完成后将打包后文件移动至 nginx 的资源目录下。例如：/data/www/ 然后按项目所需修改配置文件：例如端口号，项目地址等，例如： 12345678910server &#123; listen 8088; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location /static &#123; alias /data/www/dist/static/; &#125;&#125; 注：多说一句，如果你的服务端没有进行相关配置，那么vue-router 请一定不要使用history模式！！否则会出现路由跳转错误的bug！！我当初就是被这个问题困扰了很久，最后去看文档才发现。 2. 后端部署后端部署很简单，就是在服务器上运行 node 程序，但是不要生硬的 node server &amp; 最好是将后端文件分离出来后，使用 pm2 做负载均衡，pm2 是一个带有负载均衡功能的Node应用的进程管理器. 具体如何使用，推荐这篇专栏： 使用pm2躺着实现负载均衡 - Richardwei~的专栏 - 博客频道 - CSDN.NET 3. 前后端联系（跨域）因为后端可能运行在别的端口，那么就会出现跨域情况。使用 nginx 进行反向代理，安装完 nginx 后，配置 nginx 配置文件，即可解决该问题，例如： 12345server &#123; location /api &#123; proxy_pass http://***.***.**.**:****/api; &#125;&#125; 到此，前后端部署步骤基本完毕。 项目心得以下是除开前后端部署，我在项目中遇到的一些其他问题，也和大家分享一下。 mongodb 请务必不要在服务器上无密码裸奔。mongodb因为前段时间的 “ 赎金事件 ” 被很多人觉得安全性存在问题，但是其实是因为大多mongodb数据库在服务器上无密码裸奔。这是非常危险的，请一定不要这么做。 mongoose 中 model在起名时，会发生表名自动复数化的情况，原因为：Mongoose在创建Model时对Collection的命名策略 - 推酷因此应该按照 model -&gt; 建表的顺序，如果是从外部导入的表，例如从mysql导入，那么应该保证表名为复数形式，否则会出现无法操作collention的情况。 请务必使用集成开发环境进行项目开发，如果担心网络问题以及需要免费的私人仓库，那么可以使用一些国产的代码托管平台，真的能够为团队开发规避许多不必要的问题。 其实项目中的技术问题很多时候都不是问题，而人和人之间的问题才是真的问题……这个也是我带这个小团队后的切身感受。 后记如果大家发现我的文章中存在问题，那么请不吝赐教，大家共同进步。如果我转载的文章原作者不愿自己文章被转载，请告知，我会及时删除。如果你觉得我写的对你有点帮助，就点赞鼓励一下，三克油。 全文完","tags":[{"name":"javascript","slug":"javascript","permalink":"https://ykloveyxk.github.io/tags/javascript/"},{"name":"Vuejs","slug":"Vuejs","permalink":"https://ykloveyxk.github.io/tags/Vuejs/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://ykloveyxk.github.io/tags/Nodejs/"}]},{"title":"ORACLE数据库数据导入Mysql数据库的一个小方法","date":"2017-03-23T06:21:10.000Z","path":"2017/03/23/ORACLE数据库数据导入Mysql数据库的一个小方法/","text":"首先注明一下：CSDN的博主：完美A型血就是我 导入数据方式 采用 Oracle（pl/sql）-&gt; excel -&gt; MySQL（Navicat for mysql） 的方式 具体步骤：1. 通过pl/sql连接远程oracle数据库具体步骤方法可百度，相关资料很多。简单描述为： 下载安装客户端；配置tns文件； 修改环境变量； 配置pl/sql（tools-&gt;connet）； 连接pl/sql； 注意： 最好安装oracle的完整客户端，不要使用简易的客户端，因为简易的客户端自身不带有进行导出导入数据的功能。如果导出按钮为灰色，一般说明客户端有问题。 pl/sql好像只支持32位系统，因此安装oracle客户端时，也最好使用 32位的； 导出文件的格式有三种形式，dmp，sql和plsql自己带有的格式。这三种方式的导出文件包括sql，都不能直接导入mysql。 2. 将数据导入到excelOracle和mysql的语法不兼容，导出的数据文件不能直接导入mysql。对于数据量较小。少于10w条数据量的表，现在有一个较为笨拙的方法。即将数据导入到excel，再从excel导入mysql Pl/sql本身可以将数据导入到excel（无论是视图还是表格。都可直接导入），使用查看表数据，然后在数据显示界面的空白处点击右键，将数据导入excel保存为.xls格式即可。 3. 导入mysql这里需要使用一款mysql的官方推荐软件，Navivat for mysql，这款软件可以简易的连接服务器数据库，并将多种格式的文件导入数据库，这其中就包含.xls的excel文件。 注意： 导出的数据存在以下几点问题，首先没有id字段，需要手动命名为id； 导出的数据表记得要自己修改名称。默认名称中含有空格，也可以导入，但是导入后无法操作，mysql不认可空格； 所有字段的默认数据形式全部为varchar（255），需要根据原来的oracle数据表形式进行参照手动修改。缺陷 这个方法笨拙且试用范围窄，很明显不是正确的方法，但是也算是一个将数据进行迁移的办法，在还没有找到更好的将数据从远程oracle同步到本地mysql服务器的方法之前，可将旧一下，先用着。：） 缺点如下： 步骤较多，麻烦； 试用范围小，只适合10w行以下，理论是都可以适应，但是数据量过大比如到达百万级。从pl/sql到excel的导入过程将会十分漫长。 不能实时同步。这是现在最为致命的问题。数据必须人工的进行定时的导出导入，不能与一卡通的直连服务器进行实时的更新，毫无疑问很不合理。 求助大神！如果哪位大神有将远程oracle数据库中的数据导入mysql数据库中的比较简单或者说比较正统的方法的话，请麻烦务必要告诉我，在此感激不尽。","tags":[{"name":"ORACLE","slug":"ORACLE","permalink":"https://ykloveyxk.github.io/tags/ORACLE/"}]},{"title":"vue-login 通过一个小项目带你走进vue全栈开发","date":"2017-03-21T12:18:32.000Z","path":"2017/03/21/vue-login-通过一个项目带你走进vue全栈开发/","text":"这是一个基于 vue &amp; axios &amp; nodejs(express) &amp; mongodb(mongoose) 的登录／注册demo，面向 vue 初学者，场景虽简单，但五脏俱全。有前后台，涵盖非常多的 vue 及其相关技术的基本操作。有详细的注释，帮助大家快速上手 vue 。且我整理了一些在vue全栈开发过程中，有可能会用到的技术文章，希望大家能在这些前辈们身上有所收获。 当然如果您觉得这篇文章 or 这个项目对您的学习有所帮助，请不吝点个 star 鼓励一下，当然如果存在问题，也非常希望您能提交 issues 或者在 我的博客任意文章下留言，我会及时处理回复，和大家一起进步。 项目Github地址 vue-login 项目技术栈 前台：vue &amp; vue-router &amp; vuex &amp; vue-cli(webpack) &amp; element-ui 后台： nodejs (express) 前后台交互： axios 单点登录： jsonwebtoken Build Setup 1234567891011121314151617# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report# start servernode server.js# start mongodbmongod 项目开发推荐阅读 因为项目难度并不是很高，且我也在代码中写了较多注释，所以我不会细节到行去解释代码，而是会搜集、分享一些前辈们书写的相关技术文章，相信大家踩在巨人的肩膀上，能学到更多。 1. vue-cli 生成项目主体框架使用 vue-cli 的优点是方便快捷，能快速生成项目的主体结构。但不能一味依赖这种开发方式，还是要了解其中的技术细节。此处推荐几篇文章： vue-cli官方文档 webpack2 中文文档 vue-cli#2.0 webpack 配置分析 - 掘金（强烈推荐） 2. vue 全家桶顾名思义就是我们熟知的 vue + vue-router + vuex + … ，虽然还有很多的组件，但是基础都是 前三个。这块儿首推官方文档，我个人认为 vue 的成功除开自身素质过硬外，最大的优势就是文档写的非常的浅显易懂！所以学 vue 一定要多读官方文档。此处放出连接： Vue.js Vue-router Vuex 当然掘金上也有许多的详解文章，也推荐大家去看看。 3. 后台服务端后台主要作用是接收前台请求，处理完成后返回一个含有所需数据或状态的api接口，供前台去调用。这需要你了解熟悉 nodejs 或任意一种后端语言，以 nodejs 为例，有以下文章推荐你去阅读： 阮一峰老师的 js 教程（含node） （强烈建议把js部分也看看） Express 4.x API - 作业部落 Cmd Markdown 编辑阅读器（express 4.x 的中文文档） koa （最近常出现的一个node框架，有兴趣的可以去了解一下 ） 4. axios前后台交互vue 和 node 的交互还是主要采用 ajax 来进行，此处就介绍一个主流交互工具 axios，当然别的工具例如 vue-resource、jquery 都可以。但是 vue-resource 不维护了，jquery如果只是为了 ajax 就引入又太庞大，所以我个人是比较推荐axios。此处久推荐这几篇文章吧： axios全攻略 （我写的，羞射😳，但我个人觉得很值得阅读） Vuex2和Axios的开发 | Hope’s Blog （也是掘金作者，让理论照进现实） 5. jsonwebtoken此项目使用 jsonwebtoken 进行用户认证，其实 jsonwebtoken 也可以用来做权限控制或者向Web应用传递信息。关于 jsonwebtoken 除了它的官方文档外，还有这几篇文章可以看看： JSON Web Token-在Web应用间安全地传递信息 八幅漫画理解使用JSON Web Token 6. 组件库随着 vue 的不断发展，社区越来越活跃，因此产生了许多组件库，此处我就推荐一个我个人使用的最多的由饿了么团队开发的组件库element-ui。 element-ui 7. demo开发其实除了冥思苦想外，很多时候要多读别人的源码，从中才能有所启发。放出几个demo： 一个使用 github api写的登录程序 （掘金作者，我的这篇文章也是受他启发） vue + koa + mysql 的 todos demo （想了解 koa + mysql 如何在vue中运用可以看看） 后记当然纸上学来终觉浅，绝知此事要躬行。学完理论就需要去实践，所以希望大家多多去看看别人的代码，然后写写小demo。一定会事半功倍。希望和大家共同进步。 然后我无意发现有人未经过我同意就转发我的文章。而且未出现任何我的相关信息。我的观点是我写文章是为了方便大家，督促自己，所以转就转了，不需要我的同意，但是哪怕不出现我的名字，也请务必注一个 转 字，不要把他当作自己的文章来用。","tags":[{"name":"vuejs javascript","slug":"vuejs-javascript","permalink":"https://ykloveyxk.github.io/tags/vuejs-javascript/"}]},{"title":"axios全攻略","date":"2017-02-24T19:07:19.000Z","path":"2017/02/25/axios全攻略/","text":"随着 vuejs 作者尤雨溪发布消息，不再继续维护vue-resource，并推荐大家使用 axios 开始，axios 被越来越多的人所了解。本来想在网上找找详细攻略，突然发现，axios 的官方文档本身就非常详细！！有这个还要什么自行车！！所以推荐大家学习这种库，最好详细阅读其官方文档。大概翻译了一下 axios 的官方文档，相信大家只要吃透本文再加以实践，axios 就是小意思啦！！ 如果您觉得本文对您有帮助，不妨点个赞或关注收藏一下，您的鼓励对我非常重要。 axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 浏览器兼容性 引入方式：12345$ npm install axios$ cnpm install axios //taobao源$ bower install axios或者使用cdn：&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 举个栗子： 执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 也可以通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行 POST 请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; //两个请求现已完成 &#125;)); axios API 可以通过将相关配置传递给 axios 来进行请求。 axios(config)123456789// 发送一个 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config])12// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345'); 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名。 axios.request（config） axios.get（url [，config]） axios.delete（url [，config]） axios.head（url [，config]） axios.post（url [，data [，config]]） axios.put（url [，data [，config]]） axios.patch（url [，data [，config]]） 注意当使用别名方法时，不需要在config中指定url，method和data属性。 并发帮助函数处理并发请求。 axios.all（iterable） axios.spread（callback） 创建实例您可以使用自定义配置创建axios的新实例。 axios.create（[config]） 12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]） 请求配置 这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&#123; // `url`是将用于请求的服务器URL url: '/user', // `method`是发出请求时使用的请求方法 method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法'PUT'，'POST'和'PATCH' // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: 'Fred' &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过'timeout'，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy'定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 使用 then 时，您将收到如下响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 配置默认值 您可以指定将应用于每个请求的配置默认值。 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567//在创建实例时设置配置默认值var instance = axios.create（&#123; baseURL：'https://api.example.com'&#125;）; //在实例创建后改变默认值instance.defaults.headers.common ['Authorization'] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（'/ longRequest'，&#123; timeout：5000&#125;）; 拦截器 你可以截取请求或响应在被 then 或者 catch 处理之前 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误 1234567891011121314axios.get（'/ user / 12345'） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get（'/ user / 12345'，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除 您可以使用取消令牌取消请求。 axios cancel token API基于可取消的promise提议，目前处于阶段1。 您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source（）;axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);//取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式 默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。 或者，您可以使用qs库对数据进行编码： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promise axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScript axios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://ykloveyxk.github.io/tags/javascript/"}]},{"title":"svg图标文件引入小技巧","date":"2017-01-17T08:57:17.000Z","path":"2017/01/17/svg图标文件引入小技巧/","text":"今天刚刚get到的一个小技能，忍不住想和大家分享一下，万一有同学不太懂，刚好也可以学习一下（ps：知道的同学可以帮我斧正，感谢！）。惯例，先来简单介绍一下 svg，虽然相信大家都懂😓: SVG（可缩放矢量图形）_百度百科 svg（可缩放矢量图形）是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式。它由万维网联盟制定，是一个开放标准。 简单的说就是它是一种矢量图形，体积小，高保真，放大放小都不失真。 直接引入svg文件的方式，有以下几种： img 标签引入; css 属性 background-image: url(‘svg’); 引入; 使用 object 标签引入 ; iframe 标签引入; embed 标签引入; svg 标签引入; 但是上面的几种方法，除去方法2，都有个共同特点，都是通过一个标签来引入一个svg文件。但是在实际的开发过程中，需要加载的图标文件数目可能会有很多（尤其在移动端），因此采用标签加载的方式，会导致代码冗余，不美观，且不易维护和阅读。因此，在加载图标文件的时候，我们应该效仿 font-awesome 的加载方式。通过 图标字体文件 &amp; css 这种方式来实现。这样做最显著的优势就是，图标加载方式得到了简化和放宽。 以font-awesome为例，在引入图标字体文件和相关css文件的基础上，加载图标只需为标签添加class属性。 1&lt;i class=‘fa fa-star’&gt;&lt;/i&gt; 这样就使得svg加载非常灵活和简洁。但是如何将自己设计的svg图标转化为字体图标文件，就用到我们接下来的一个小方法： 首先登陆一个网站（免费哒）： Icon Font &amp; SVG Icon Sets ❍ IcoMoon 点击右上方的 IcoMoon App 按钮； 在新载入页面中，点击左上方的 Import Icons 按钮，选择自己需要引入的 .svg 图标； 在预览界面选中需要包含的图标后，点击右下方的 Generate Font 按钮； 接着将鼠标置于我们加载的图标上方，点击 Get Code 查看如何引入这个图标（看看多贴心）； 最后download ，引入字体文件和css文件。就可以调用啦。 这只是实际开发中的一个小技巧，小方法，分享给还不知道的人。谢谢。当然觉得有用的话，不妨点个赞鼓励下（羞射）。","tags":[{"name":"svg","slug":"svg","permalink":"https://ykloveyxk.github.io/tags/svg/"}]},{"title":"浅谈javascript垃圾收集机制","date":"2017-01-03T00:00:32.000Z","path":"2017/01/03/垃圾收集/","text":"因为已经研二了，眼看就要找工作了，心中很忐忑。好怕面试官当众吊打我，真的好怕好怕……所以想着开个博客，整理分享一些js的基础知识，充实自己的同时，也能分享给需要的人。 今天想要分享的小知识，是关于javascript的垃圾收集机制（GC(Garbage Collection) ）。 自动垃圾收集机制不同于C/C++需要编程人员手动跟踪内存的使用情况，javascript拥有一套自动垃圾收集机制，也就是说，在我们的开发过程中，并不用去考虑内存的分配和回收问题，这些问题都由执行环境负责，它自动管理代码执行过程中内存的分配与回收，让编码人员能将更多精力放在业务功能实现。而手动跟踪内存自身也有其弊端，例如很繁琐，变量数目很多时人工操作很容易遗漏，造成资源浪费等。 自动垃圾收集机制，它的原理其实很简单： 确定变量中有哪些还在使用，哪些已经不再使用，然后垃圾收集器会按照固定的时间间隔去周期性的释放已经不再继续使用的变量所占的内存。 但是怎么界定变量有没有被使用，就需要考虑它的生命周期。 变量的生命周期在不考虑卸载页面，注销系统的基础上，全局变量是一直都会存在的，因为系统不明确什么时候还会用到它，所以全局变量通常不会被垃圾收集机制所回收。js面试中的另一个特色问题闭包之所以能够在函数外部读取函数内部局部变量，保证该局部变量不被垃圾收集器回收，就是因为定义了一个外部引用，使得整个函数与全局变量连接在一起。（说的比较笼统，之后在闭包部分详述） 而局部变量只在函数执行的过程中存在，在这个过程中，会为局部变量分配内存空间，用来储存它的值。当函数结束时，局部变量就可以界定为不再继续使用，于是就会释放它的内存。但这只是很简单的一种情况，随着实现的不同，垃圾收集器对“有用”，“无用”的标示策略也不同，总体来说，有以下两种： 标记清除 引用计数 标记清除法标记清除是javascript中最常用的垃圾收集机制。简单的来说就是：变量进入环境(即执行上下文，例如全局环境、函数环境)，标记该变量进入环境；出环境则标记变量离开环境。 然后垃圾收集器会保留环境中的变量和被环境中变量引用的变量（其实就是闭包），定时循环释放除此之外的离开环境的变量的内存。大多现代浏览器都采取这个策略进行垃圾收集，它们之间的区别在于垃圾收集器的回收间隔时间。 引用计数法 要明确引用计数法，首先需要了解什么是引用？ 此处的引用是指一个对象对另一个对象的访问权限，可以访问，则表示这个对象引用另一个对象。 引用计数法并不常用，出现在IE早期，它的原理也很简单：跟踪每个值被引用的次数，当声明变量并赋给他一个引用类型的值时，则该值引用次数为1，将其赋给另一个变量时，引用次数就变为2，以此类推；相反，如果引用这个值的那个变量引用了别的值，那么这个值的引用次数就减1，当然新引用的那个值的次数加1。最后，当次数变为0时，则默认改值已不再被需要，就会被回收器回收。 但是该方法有一个巨大缺陷，就是它存在循环引用：1234567function referenceCount() &#123; var variable_a = &#123;&#125;; var variable_b = &#123;&#125;; variable_a.prop = variable_b; variable_b.prop = variable_a;&#125;referenceCount(); 此时variable_a, variable_b通过各自属性相互引用，但是函数已经执行完毕，本来应该将这两个对象所占内存释放，但在引用计数法中它们不会被回收。 以上，就是关于javascript中垃圾收集机制的一些简单介绍。虽然它可能对我们实际编程意义不大，但是对我们了解javascript这门语言的运行机制，还是很有帮助的。因为我也是前端届的小学生，如有问题，希望大家严厉指出，谢谢。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://ykloveyxk.github.io/tags/javascript/"}]}]