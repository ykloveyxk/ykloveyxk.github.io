<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[vue-login 通过一个小项目带你走进vue全栈开发]]></title>
      <url>%2F2017%2F03%2F21%2Fvue-login-%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9Bvue%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[这是一个基于 vue &amp; axios &amp; nodejs(express) &amp; mongodb(mongoose) 的登录／注册demo，面向 vue 初学者，场景虽简单，但五脏俱全。有前后台，涵盖非常多的 vue 及其相关技术的基本操作。有详细的注释，帮助大家快速上手 vue 。且我整理了一些在vue全栈开发过程中，有可能会用到的技术文章，希望大家能在这些前辈们身上有所收获。 当然如果您觉得这篇文章 or 这个项目对您的学习有所帮助，请不吝点个 star 鼓励一下，当然如果存在问题，也非常希望您能提交 issues 或者在 我的博客任意文章下留言，我会及时处理回复，和大家一起进步。 项目Github地址 vue-login 项目技术栈 前台：vue &amp; vue-router &amp; vuex &amp; vue-cli(webpack) &amp; element-ui 后台： nodejs (express) 前后台交互： axios 单点登录： jsonwebtoken Build Setup 1234567891011121314151617# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report# start servernode server.js# start mongodbmongod 项目开发推荐阅读 因为项目难度并不是很高，且我也在代码中写了较多注释，所以我不会细节到行去解释代码，而是会搜集、分享一些前辈们书写的相关技术文章，相信大家踩在巨人的肩膀上，能学到更多。 1. vue-cli 生成项目主体框架使用 vue-cli 的优点是方便快捷，能快速生成项目的主体结构。但不能一味依赖这种开发方式，还是要了解其中的技术细节。此处推荐几篇文章： vue-cli官方文档 webpack2 中文文档 vue-cli#2.0 webpack 配置分析 - 掘金（强烈推荐） 2. vue 全家桶顾名思义就是我们熟知的 vue + vue-router + vuex + … ，虽然还有很多的组件，但是基础都是 前三个。这块儿首推官方文档，我个人认为 vue 的成功除开自身素质过硬外，最大的优势就是文档写的非常的浅显易懂！所以学 vue 一定要多读官方文档。此处放出连接： Vue.js Vue-router Vuex 当然掘金上也有许多的详解文章，也推荐大家去看看。 3. 后台服务端后台主要作用是接收前台请求，处理完成后返回一个含有所需数据或状态的api接口，供前台去调用。这需要你了解熟悉 nodejs 或任意一种后端语言，以 nodejs 为例，有以下文章推荐你去阅读： 阮一峰老师的 js 教程（含node） （强烈建议把js部分也看看） Express 4.x API - 作业部落 Cmd Markdown 编辑阅读器（express 4.x 的中文文档） koa （最近常出现的一个node框架，有兴趣的可以去了解一下 ） 4. axios前后台交互vue 和 node 的交互还是主要采用 ajax 来进行，此处就介绍一个主流交互工具 axios，当然别的工具例如 vue-resource、jquery 都可以。但是 vue-resource 不维护了，jquery如果只是为了 ajax 就引入又太庞大，所以我个人是比较推荐axios。此处久推荐这几篇文章吧： axios全攻略 （我写的，羞射😳，但我个人觉得很值得阅读） Vuex2和Axios的开发 | Hope’s Blog （也是掘金作者，让理论照进现实） 5. jsonwebtoken此项目使用 jsonwebtoken 进行用户认证，其实 jsonwebtoken 也可以用来做权限控制或者向Web应用传递信息。关于 jsonwebtoken 除了它的官方文档外，还有这几篇文章可以看看： JSON Web Token-在Web应用间安全地传递信息 八幅漫画理解使用JSON Web Token 6. 组件库随着 vue 的不断发展，社区越来越活跃，因此产生了许多组件库，此处我就推荐一个我个人使用的最多的由饿了么团队开发的组件库element-ui。 element-ui 7. demo开发其实除了冥思苦想外，很多时候要多读别人的源码，从中才能有所启发。放出几个demo： 一个使用 github api写的登录程序 （掘金作者，我的这篇文章也是受他启发） vue + koa + mysql 的 todos demo （想了解 koa + mysql 如何在vue中运用可以看看） 后记当然纸上学来终觉浅，绝知此事要躬行。学完理论就需要去实践，所以希望大家多多去看看别人的代码，然后写写小demo。一定会事半功倍。希望和大家共同进步。 然后我无意发现有人未经过我同意就转发我的文章。而且未出现任何我的相关信息。我的观点是我写文章是为了方便大家，督促自己，所以转就转了，不需要我的同意，但是哪怕不出现我的名字，也请务必注一个 转 字，不要把他当作自己的文章来用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[axios全攻略]]></title>
      <url>%2F2017%2F02%2F25%2Faxios%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
      <content type="text"><![CDATA[随着 vuejs 作者尤雨溪发布消息，不再继续维护vue-resource，并推荐大家使用 axios 开始，axios 被越来越多的人所了解。本来想在网上找找详细攻略，突然发现，axios 的官方文档本身就非常详细！！有这个还要什么自行车！！所以推荐大家学习这种库，最好详细阅读其官方文档。大概翻译了一下 axios 的官方文档，相信大家只要吃透本文再加以实践，axios 就是小意思啦！！ 如果您觉得本文对您有帮助，不妨点个赞或关注收藏一下，您的鼓励对我非常重要。 axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 浏览器兼容性 引入方式：12345$ npm install axios$ cnpm install axios //taobao源$ bower install axios或者使用cdn：&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 举个栗子： 执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 也可以通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行 POST 请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; //两个请求现已完成 &#125;)); axios API 可以通过将相关配置传递给 axios 来进行请求。 axios(config)123456789// 发送一个 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config])12// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345'); 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名。 axios.request（config） axios.get（url [，config]） axios.delete（url [，config]） axios.head（url [，config]） axios.post（url [，data [，config]]） axios.put（url [，data [，config]]） axios.patch（url [，data [，config]]） 注意当使用别名方法时，不需要在config中指定url，method和data属性。 并发帮助函数处理并发请求。 axios.all（iterable） axios.spread（callback） 创建实例您可以使用自定义配置创建axios的新实例。 axios.create（[config]） 12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]） 请求配置 这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&#123; // `url`是将用于请求的服务器URL url: '/user', // `method`是发出请求时使用的请求方法 method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法'PUT'，'POST'和'PATCH' // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: 'Fred' &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过'timeout'，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy'定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 使用 then 时，您将收到如下响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 配置默认值 您可以指定将应用于每个请求的配置默认值。 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567//在创建实例时设置配置默认值var instance = axios.create（&#123; baseURL：'https://api.example.com'&#125;）; //在实例创建后改变默认值instance.defaults.headers.common ['Authorization'] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（'/ longRequest'，&#123; timeout：5000&#125;）; 拦截器 你可以截取请求或响应在被 then 或者 catch 处理之前 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误 1234567891011121314axios.get（'/ user / 12345'） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get（'/ user / 12345'，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除 您可以使用取消令牌取消请求。 axios cancel token API基于可取消的promise提议，目前处于阶段1。 您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source（）;axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);//取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式 默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。 或者，您可以使用qs库对数据进行编码： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promise axios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScript axios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[svg图标文件引入小技巧]]></title>
      <url>%2F2017%2F01%2F17%2Fsvg%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[今天刚刚get到的一个小技能，忍不住想和大家分享一下，万一有同学不太懂，刚好也可以学习一下（ps：知道的同学可以帮我斧正，感谢！）。惯例，先来简单介绍一下 svg，虽然相信大家都懂😓: SVG（可缩放矢量图形）_百度百科 svg（可缩放矢量图形）是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式。它由万维网联盟制定，是一个开放标准。 简单的说就是它是一种矢量图形，体积小，高保真，放大放小都不失真。 直接引入svg文件的方式，有以下几种： img 标签引入; css 属性 background-image: url(‘svg’); 引入; 使用 object 标签引入 ; iframe 标签引入; embed 标签引入; svg 标签引入; 但是上面的几种方法，除去方法2，都有个共同特点，都是通过一个标签来引入一个svg文件。但是在实际的开发过程中，需要加载的图标文件数目可能会有很多（尤其在移动端），因此采用标签加载的方式，会导致代码冗余，不美观，且不易维护和阅读。因此，在加载图标文件的时候，我们应该效仿 font-awesome 的加载方式。通过 图标字体文件 &amp; css 这种方式来实现。这样做最显著的优势就是，图标加载方式得到了简化和放宽。 以font-awesome为例，在引入图标字体文件和相关css文件的基础上，加载图标只需为标签添加class属性。 1&lt;i class=‘fa fa-star’&gt;&lt;/i&gt; 这样就使得svg加载非常灵活和简洁。但是如何将自己设计的svg图标转化为字体图标文件，就用到我们接下来的一个小方法： 首先登陆一个网站（免费哒）： Icon Font &amp; SVG Icon Sets ❍ IcoMoon 点击右上方的 IcoMoon App 按钮； 在新载入页面中，点击左上方的 Import Icons 按钮，选择自己需要引入的 .svg 图标； 在预览界面选中需要包含的图标后，点击右下方的 Generate Font 按钮； 接着将鼠标置于我们加载的图标上方，点击 Get Code 查看如何引入这个图标（看看多贴心）； 最后download ，引入字体文件和css文件。就可以调用啦。 这只是实际开发中的一个小技巧，小方法，分享给还不知道的人。谢谢。当然觉得有用的话，不妨点个赞鼓励下（羞射）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈javascript垃圾收集机制]]></title>
      <url>%2F2017%2F01%2F03%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%2F</url>
      <content type="text"><![CDATA[因为已经研二了，眼看就要找工作了，心中很忐忑。好怕面试官当众吊打我，真的好怕好怕……所以想着开个博客，整理分享一些js的基础知识，充实自己的同时，也能分享给需要的人。 今天想要分享的小知识，是关于javascript的垃圾收集机制（GC(Garbage Collection) ）。 自动垃圾收集机制不同于C/C++需要编程人员手动跟踪内存的使用情况，javascript拥有一套自动垃圾收集机制，也就是说，在我们的开发过程中，并不用去考虑内存的分配和回收问题，这些问题都由执行环境负责，它自动管理代码执行过程中内存的分配与回收，让编码人员能将更多精力放在业务功能实现。而手动跟踪内存自身也有其弊端，例如很繁琐，变量数目很多时人工操作很容易遗漏，造成资源浪费等。 自动垃圾收集机制，它的原理其实很简单： 确定变量中有哪些还在使用，哪些已经不再使用，然后垃圾收集器会按照固定的时间间隔去周期性的释放已经不再继续使用的变量所占的内存。 但是怎么界定变量有没有被使用，就需要考虑它的生命周期。 变量的生命周期在不考虑卸载页面，注销系统的基础上，全局变量是一直都会存在的，因为系统不明确什么时候还会用到它，所以全局变量通常不会被垃圾收集机制所回收。js面试中的另一个特色问题闭包之所以能够在函数外部读取函数内部局部变量，保证该局部变量不被垃圾收集器回收，就是因为定义了一个外部引用，使得整个函数与全局变量连接在一起。（说的比较笼统，之后在闭包部分详述） 而局部变量只在函数执行的过程中存在，在这个过程中，会为局部变量分配内存空间，用来储存它的值。当函数结束时，局部变量就可以界定为不再继续使用，于是就会释放它的内存。但这只是很简单的一种情况，随着实现的不同，垃圾收集器对“有用”，“无用”的标示策略也不同，总体来说，有以下两种： 标记清除 引用计数 标记清除法标记清除是javascript中最常用的垃圾收集机制。简单的来说就是：变量进入环境(即执行上下文，例如全局环境、函数环境)，标记该变量进入环境；出环境则标记变量离开环境。 然后垃圾收集器会保留环境中的变量和被环境中变量引用的变量（其实就是闭包），定时循环释放除此之外的离开环境的变量的内存。大多现代浏览器都采取这个策略进行垃圾收集，它们之间的区别在于垃圾收集器的回收间隔时间。 引用计数法 要明确引用计数法，首先需要了解什么是引用？ 此处的引用是指一个对象对另一个对象的访问权限，可以访问，则表示这个对象引用另一个对象。 引用计数法并不常用，出现在IE早期，它的原理也很简单：跟踪每个值被引用的次数，当声明变量并赋给他一个引用类型的值时，则该值引用次数为1，将其赋给另一个变量时，引用次数就变为2，以此类推；相反，如果引用这个值的那个变量引用了别的值，那么这个值的引用次数就减1，当然新引用的那个值的次数加1。最后，当次数变为0时，则默认改值已不再被需要，就会被回收器回收。 但是该方法有一个巨大缺陷，就是它存在循环引用：1234567function referenceCount() &#123; var variable_a = &#123;&#125;; var variable_b = &#123;&#125;; variable_a.prop = variable_b; variable_b.prop = variable_a;&#125;referenceCount(); 此时variable_a, variable_b通过各自属性相互引用，但是函数已经执行完毕，本来应该将这两个对象所占内存释放，但在引用计数法中它们不会被回收。 以上，就是关于javascript中垃圾收集机制的一些简单介绍。虽然它可能对我们实际编程意义不大，但是对我们了解javascript这门语言的运行机制，还是很有帮助的。因为我也是前端届的小学生，如有问题，希望大家严厉指出，谢谢。]]></content>
    </entry>

    
  
  
</search>
